
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="Welcome!">
    <meta name="keywords" content="software engineer, senior software engineer, node.js, node, javascript, robotics, viola jones, face detection, face recognition">
    <title>Viola Jones Face Detection Algorithm Easy Explanation - patil-rahuls.github.io</title>
    <link rel="stylesheet" href="/styles.css">
  </head>
   <body>
      <div class="wrapper">
         <aside>
            <ul id="menu"></ul>
            <div id="loading"></div>
         </aside>
        <article>
            <h1 id="heading"><a class="links" href="/index">Home</a> | Viola Jones Face Detection Algorithm Explained</h1>
            <div>
               <table class="fade-in">
                  <tbody>
                     <tr><td>
                           <span class="code" id="message"><i style="color:#aaa">Posted on 27th September 2018</i></span><br>
                           <!-- <a class="fb-xfbml-parse-ignore" href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Fpatil-rahuls.github.io/viola-jones-face-detection-algorithm-easy-explanation&src=sdkpreparse" target="_blank">Share</a>
                           <div style="display:contents" class="fb-share-button" data-href="https://patil-rahuls.github.io/viola-jones-face-detection-algorithm-easy-explanation" data-layout="button_count"></div> -->
                     </td></tr>
                     <tr><td><br>This is a brief tutorial on Viola-Jones face detection algorithm. If you haven't watched the video shown below, I suggest you to watch it first.</td></tr>
                     <tr><td><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen class="article-image" frameborder="0" height="315" src="https://www.youtube.com/embed/_QZLbR67fUU" width="561px"></iframe></td></tr>
                     <tr><td><i class="captions">Video lecture on Viola Jones Face Detection Algorithm.</i></td></tr>
                     <tr><td><strong>Introduction<strong></td></tr>
                     <tr><td>In 2001, Paul Viola and Michael Jones proposed a framework called Viola–Jones object detection framework. It can be trained to detect variety of objects of different classes. However it was primarily developed for face detection.</td></tr>
                     <tr><td><strong>Why Viola-Jones face detection Algorithm?</strong></td></tr>
                     <tr><td>Viola–Jones algorithm is very robust. It has a very high detection rate. The algorithm is fast enough to be implemented in real time applications. And, If we optimize our implemented code, we can make it run much more faster.</td></tr>
                     <tr><td><strong>Viola-Jones Face detection algorithm in layman terms</strong></td></tr>
                     <tr><td>A face detection algorithm is designed by giving input as some faces and non faces and a training classifier. A training classifier is something which identifies a face from the inputs. We train a <i>classifier</i> using faces and non faces and once the training is done, the data that we have got can be used to detect faces from an image.<br><br>To put this in more simpler words, we show some images of face to an alien who has no previous knowledge of what the human face is. We show some hundreds or thousands of human faces and tell it that it is a human face. And similarly we again show some hundreds or thousands of <b>non faces (or non human faces)</b> and tell it that these are non-faces. Once that alien is trained to identify the features, we give it an input image and it is then able to classify it as a face or a non face.</td></tr>
                     <tr><td><strong>Concept</strong></td></tr>
                     <tr><td>By implementing Viola-Jones face detection algorithm, we are trying to train our computer to understand what a face is and/or what a non face is. Once the computer is trained, it extracts certain features and this data is stored in a file. All we do is, we take that file, when we get a new input image, check the features from that file and apply each feature set to the input image. There are various stages of feature comparison. If it passes through each stages of that feature comparison, then a face is detected in the input image.<br>Hope you've got the basic idea of Viola-Jones face detection algorithm. Lets go deep.</td></tr>
                     <tr><td><strong>Haar Features</strong></td></tr>
                     <tr><td>Haar Features are basically similar to the convolution kernels, which are used to detect the presence of the features in an image. Consider the following image showing the Haar features used in Viola-Jones face detection algorithm.</td></tr>
                     <tr><td><img src="assets/img/viola-jones-face-detection-algorithm-easy-explanation/Haar-features-viola-jones-face-detection.png" width="300"></td></tr>
                     <tr><td><i class="captions">1. Haar features</i></td></tr>
                     <tr><td><br>A black region is replaced by +1 and the white region is replaced with -1. When we apply this mask to an input image, we just subtract the pixel values under white region from the pixel values under black region and the output will be a single value.<br><br>So what we understand from this is that, all these Haar features have some sort of resemblance to some facial features or characteristics of faces. So, Haar features represent some <i>characteristics of a face</i>. Viola-Jones algorithm uses a 24x24 sub-window from an image, and it calculates these features all over the image.</td></tr>
                     <tr><td></td></tr>
                     <tr><td><img src="assets/img/viola-jones-face-detection-algorithm-easy-explanation/haar-feature-1.png" height="50"></td></tr>
                     <tr><td><i class="captions">2. a simple 2-pixel Haar feature</i></td></tr>
                     <tr><td>Let us say you have a feature as shown above which is of 2 pixel dimension. This feature is applied at the top-left pixel of the input image and the value is calculated. Then it is shifted ahead right by one unit(pixel) and again the value is calculated. And so on this 2 pixel feature is moved across the entire input image till we end up reaching bottom corner pixel of the image. Then we increase the size of this feature. We make it 2 pixel white and 2 pixel black, resulting in a 4 pixel size feature. We apply this feature to the image all over again by shifting it pixel by pixel and we get the values. Further, we make it 4 pixel white and 4 pixel black, and again apply it to the image to get values. Similarly same thing is done by taking all the other features and is applied to the image to to get values.<br><br>Considering all the variation of size, position of all these features, we end up calculating about 160,000+ features in this 24x24 window, as each single type of feature is repeated all over the image in all scales, sizes and positions; when everything combined, we have a many combinations. Now for such a case, we need to evaluate a huge set of features for every 24x24 sub-window in any new image. For real time face detection this doesn't look practical.<br><br>So, we eliminate the redundant features (the features which are not useful) and select only those features which are very very useful for face detection. This is done by <b>Adaboost</b>.</td></tr>
                     <tr><td></td></tr>
                     <tr><td><strong>Adaboost</strong></td></tr>
                     <tr><td>Adaboost eliminates all the redundant features and it narrows it down to several thousands of features that are very useful. Now before going towards Adaboost, lets talk about an important concept called <b>Integral Image</b>. As we know, in the algorithm, every single time we need to sum up all the pixels in the black region and then sum up all the pixels in the white region. Whenever we want to compute the sum of any region say black region, this is computationally inefficient if computing for real time because it will be a lengthy process for thousands of features. So Viola-Jones have came up with an idea which solves this problem.<br><br>The basic Idea behind integral image is, say we want to calculate area of a black patch in the below image, we do not need to sum up all the pixels, rather, we use the corner values of this patch and do a simple calculation which is described in the coming section.</td></tr>
                     <tr><td><img src="assets/img/viola-jones-face-detection-algorithm-easy-explanation/black-patch.png"></td></tr>
                     <tr><td><i class="captions">3. feature regions (B/W patches) in an image</i></td></tr>
                     <tr><td><br>In an integral image the value at pixel (x,y) is the sum of pixels above and to the left of (x,y).</i><br>Let's say this is a given input image and we want to calculate the integral image.</td></tr>
                     <tr><td></td></tr>
                     <tr><td><img src="assets/img/viola-jones-face-detection-algorithm-easy-explanation/integral-image-example.png"></td></tr>
                     <tr><td><i class="captions">4. an example of an integral image</i></td></tr>
                     <tr><td>To get a new value at a particular pixel we sum up all the pixel values falling in top and left region. The resultant is an Integral Image. The integral image allows for the calculation of sum of all pixels inside any given rectangle using only four corner values of the rectangle.</td></tr>
                     <tr><td>Consider this example</td></tr>
                     <tr><td><img src="assets/img/viola-jones-face-detection-algorithm-easy-explanation/integral-image.png"></td></tr>
                     <tr><td><i class="captions">5. integral image</i></td></tr>
                     <tr><td>The Integral sum inside rectangle D, we can compute as : ii(4) + ii(1) - ii(2) - ii(3).<br>Using the integral image representation one can compute the value of any rectangular sum in constant time.<br><br>Lets get back to Adaboost. How does it remove the redundant features? We have all the combinations of sizes of all the 160,000+ features. But are all of them relevant? Definitely No. For example the below feature, which is used to detect bridge of the nose, gives us maximum values only on the nose bridge region of the face.</td></tr>
                     <tr><td></td></tr>
                     <tr><td><img src="assets/img/viola-jones-face-detection-algorithm-easy-explanation/nose-haar-feature.png"></td></tr>
                     <tr><td><i class="captions">6. Haar features</i></td></tr>
                     <tr><td>For rest of the face region it is irrelevant. This relevance and irrelevance is determined by Adaboost. It selects only few features which are relevant. Adaboost is a machine learning algorithm which helps in finding only the best features among all the 160,000+ features. After these features are found, a weighted combination of all these features are used in evaluating and deciding any given window has a face or not. In mathematical terms, it gives weight to each feature denoted by <b>α</b>. And the linear combination of all these weighted features is used to determine whether face is detected or not.<br><br><i>F(x) = α<sub>1</sub>f<sub>1</sub>(x) + α<sub>2</sub>f<sub>2</sub>(x) + α<sub>3</sub>f<sub>3</sub>(x) + ...</i><br><br>Here <i>F(x)</i> is called a strong classifier, and the α<sub>n</sub>f<sub>n</sub>(x) are called weak classifiers. A weak classifier is a good feature or a relevant feature extracted by Adaboost, which at least performs better than random guessing. The output of a weak classifier is either 1 or 0. It results in 1 when it has performed well and identified the feature on the input image. Generally around 2500 features are used to form a strong classifier.</td></tr>
                     <tr><td></td></tr>
                     <tr><td><strong>Cascading</strong></td></tr>
                     <tr><td>The computed strong classifier is also called a detector. The basic principal of Viola-Jones Face detection algorithm is to scan the detector many times through the same image each time with a new size.<br><br>Lets say we have an input image of 640X480 pixels resolution, we need to move this 24x24 window all through the image.<br>For every 24x24 window, we need to evaluate 2500 features that we obtain after performing Adaboost and take a linear combination of all those 2500 outputs to detect whether it exceeds a certain threshold or not, and then decide whether a face is detected or not. Now even though an image is detected in an input image, an excessive large amount of evaluated sub-windows would still be negative.<br><br>In simpler terms, instead of using these 2500 features all the time on every single 24x24 window, we use cascades. Out of 2500 features, we make sets of features. Lets say first 10 features are kept in one classifier, then next 10-20 features in another classifier and so on. Though the complexity is increased, but the advantage is that, when we apply this cascade on a certain window of 24x24 size on an given image, based on the output of the first classifier, we can check if it is a face or not. These 2500 features are arranged in a cascading manner as shown below.</td></tr>
                     <tr><td><img src="assets/img/viola-jones-face-detection-algorithm-easy-explanation/cascades.png"></td></tr>
                     <tr><td><i class="captions">7. Cascades</i></td></tr>
                     <tr><td>With this an input can be rejected quickly from first or first few stages instead of evaluating all the 2500 features. In real time when we need to detect faces, this gives us a lot of computational advantage.</td></tr>
                     <tr><td>&nbsp;</td></tr>
                     <!-- <tr><td><strong>Thank You! Please share your comments.</strong></td></tr>
                     <tr><td><hr><div class="fb-comments" data-href="https://patil-rahuls.github.io/viola-jones-face-detection-algorithm-easy-explanation" data-numposts="5"></div></td></tr> -->
                     <a class="links" target="_blank" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A//patil-rahuls.github.io/viola-jones-face-detection-algorithm-easy-explanation">Share on LinkedIn</a><br>
                     <a class="links" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https%3A//patil-rahuls.github.io/viola-jones-face-detection-algorithm-easy-explanation">Share on Facebook</a><br>
                     <a class="links" target="_blank" href="https://twitter.com/intent/tweet?url=https://patil-rahuls.github.io/viola-jones-face-detection-algorithm-easy-explanation&text=">Share on X</a><br>
                     <a class="links" target="_blank" href="mailto:info@example.com?&subject=&cc=&bcc=&body=https://patil-rahuls.github.io/viola-jones-face-detection-algorithm-easy-explanation%0A">Share on e-mail</a>
                     <tr><td>&nbsp; <br></td></tr>
                     <tr><td>&nbsp; <br></td></tr>
                  </tbody>
               </table>
            </div>
        </article>
     </div>

     <footer>
      <ul class="footer" style="list-style:none;">
       <li>
          <a href="/contact" style="display:inline-block">contact</a>
          &nbsp;
          <a href="/privacy" style="display:inline-block">privacy</a>
          &nbsp;
          <div id="newsletter_form">
             <button id="mobileMenuBtn">
               <div class="hamburger">
                  <span></span>
                  <span></span>
                  <span></span>
              </div>
            </button>
             <!-- <button id="subscribe">Subscribe </button>
             <input  id="newsletter" type="text" placeholder="for newsletter"> -->
          </div>
       </li>
      </ul>

      <section id="mobileMenu" hidden="hidden">
         <button id="closeMobileMenuBtn" title="Close">&#x2715;</button>
         <ul id="mobileMenuList"></ul>
      </section>
   </footer>

    <script src="/config.js"></script>
    <script src="/script.js"></script>
 </body>
</html>